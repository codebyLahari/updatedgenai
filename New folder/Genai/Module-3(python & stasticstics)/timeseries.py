# -*- coding: utf-8 -*-
"""timeseries.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_uY0ez8aEwGJk3cqNYXy_ONHi-e-pKq0
"""

import kagglehub
import os
import pandas as pd

# Download latest version
path = kagglehub.dataset_download("meetnagadia/coco-cola-stock-data-19622021")

print("Path to dataset files:", path)
csv_file=None
for file in os.listdir(path):
    if file.endswith(".csv"):
        csv_file = os.path.join(path, file)
        break
if csv_file is None:
    print("No CSV file found in the downloaded dataset.")
else:
  print(f"Found CSV file: {csv_file}")
df = pd.read_csv(csv_file)
print(df.head())

# Check for missing values
print(df.isnull().sum())

# Optionally, fill or drop missing values
df.fillna(method='ffill', inplace=True)  # Forward fill

df.head(5)

df.tail(5)

# check the column names
print(df.columns.tolist())

import matplotlib.pyplot as plt
import pandas as pd # Importing pandas for data manipulation

# Plotting the resampled data
plt.figure(figsize=(14, 7))

# Convert the 'Date' column to datetime if it's not already
df['Date'] = pd.to_datetime(df['Date']) # This line converts the 'Date' column to datetime

# Filter rows where the date is between 1998 and 2002 (inclusive)
#df = df[(df['Date'].dt.year >= 1998) & (df['Date'].dt.year <= 2020)]

# Access the 'Production' column from the DataFrame 'df'
plt.plot(df['Date'], df['Volume'], label='Average Volume', color='orange')
plt.title('Average Volume')
plt.xlabel('Date')
plt.ylabel('Volume')
plt.legend()
plt.grid()
plt.show()

from statsmodels.tsa.ar_model import AutoReg

# Fit the AR model (we can try different lags, but let's start with lag=1)
model = AutoReg(df['Volume'].dropna(), lags=5)
model_fitted = model.fit()

# Print model summary
print(model_fitted.summary())

# Forecasting the next 10 years (365 days per year)
forecast_steps = 10 * 365  # 10 years of daily data

# Forecast the next 'forecast_steps' periods
forecast_ar = model_fitted.predict(start=len(df), end=len(df) + forecast_steps - 1, dynamic=False)

# Generate future dates for forecasting
future_dates = pd.date_range(df.index[-1], periods=forecast_steps + 1, freq='D')[1:]

# Plot historical data and forecast
plt.figure(figsize=(10, 6))
plt.plot(df.index, df['Volume'], label='Historical Volume')
plt.plot(future_dates, forecast_ar, label='AR Forecasted Volume', color='red')
plt.title('Coca-Cola Stock Volume Forecast (AR Model)')
plt.xlabel('Date')
plt.ylabel('Volume')
plt.legend(loc='upper left')
plt.show()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Assuming df is already loaded with 'Volume' column and Date is set as index

# Forecasting the next 10 years (365 days per year)
forecast_steps = 10 * 365  # 10 years of daily data

# Choose the window size for the Moving Average
window_size = 30  # Example: Use 30 days for the moving average (adjust as needed)

# Compute the rolling moving average (SMA)
df['MA'] = df['Volume'].rolling(window=window_size).mean()

df = df.set_index('Date')
# Plot historical data and the moving average
plt.figure(figsize=(10, 6))
plt.plot(df.index, df['Volume'], label='Historical Volume')
plt.plot(df.index, df['MA'], label=f'{window_size}-Day Moving Average', color='orange')
plt.title('Coca-Cola Stock Volume with Moving Average')
plt.xlabel('Date')
plt.ylabel('Volume')
plt.legend(loc='upper left')
plt.show()

# Forecast the next 'forecast_steps' periods using the last value of the moving average
last_ma_value = df['MA'].iloc[-1]  # Get the last moving average value

# Create a series of forecasted values using the last moving average value
forecast_ma = [last_ma_value] * forecast_steps

# Generate future dates for forecasting (based on the length of the forecast)
future_dates = pd.date_range(df.index[-1], periods=forecast_steps + 1, freq='D')[1:]

# Plot historical data and forecasted values using the moving average
plt.figure(figsize=(10, 6))
plt.plot(df.index, df['Volume'], label='Historical Volume')
plt.plot(future_dates, forecast_ma, label='MA Forecasted Volume', color='green')
plt.title('Coca-Cola Stock Volume Forecast (Moving Average Model)')
plt.xlabel('Date')
plt.ylabel('Volume')
plt.legend(loc='upper left')
plt.show()

from statsmodels.tsa.arima.model import ARIMA
# Forecasting the next 10 years (365 days per year)
forecast_steps = 10 * 365  # 10 years of daily data

# Apply the Moving Average (MA) model (ARIMA with p=0, d=0, q=1)
model_ma = ARIMA(df['Volume'], order=(0, 0, 1))  # (p, d, q) = (0, 0, 1) for MA model
model_ma_fitted = model_ma.fit()

# Print MA model summary
print(model_ma_fitted.summary())

# Forecast the next 'forecast_steps' periods (10 years worth of days)
forecast_ma = model_ma_fitted.forecast(steps=forecast_steps)

# Generate future dates for forecasting
future_dates = pd.date_range(df.index[-1], periods=forecast_steps + 1, freq='D')[1:]

# Plot historical data and forecast
plt.figure(figsize=(10, 6))
plt.plot(df.index, df['Volume'], label='Historical Volume')
plt.plot(future_dates, forecast_ma, label='MA Forecasted Volume', color='green')
plt.title('Coca-Cola Stock Volume Forecast (MA Model)')
plt.xlabel('Date')
plt.ylabel('Volume')
plt.legend(loc='upper left')
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

# Assuming your dataframe is already loaded, and 'Volume' is the column of interest.
# Set the 'Date' column as the index if it's not already
# df.set_index('Date', inplace=True)

# Plot ACF and PACF for the 'Volume' column
plt.figure(figsize=(12, 6))

# ACF Plot
plt.subplot(121)  # 1 row, 2 columns, first subplot
plot_acf(df['Volume'], lags=50, ax=plt.gca())  # Adjust lags as needed
plt.title("AutoCorrelation Function (ACF)")

# PACF Plot
plt.subplot(122)  # 1 row, 2 columns, second subplot
plot_pacf(df['Volume'], lags=50, ax=plt.gca())  # Adjust lags as needed
plt.title("Partial AutoCorrelation Function (PACF)")

plt.tight_layout()
plt.show()

print(df.info())
print(df.columns)

from statsmodels.tsa.seasonal import seasonal_decompose

# Decompose the time series into trend, seasonal, and residual components
decomposition = seasonal_decompose(df['Close'], model='multiplicative', period=12)  # assuming monthly data

# Plot the decomposition
plt.figure(figsize=(12, 8))

plt.subplot(411)
plt.plot(df['Close'], label='Original')
plt.title('Original Time Series')
plt.xlabel('Date')  # X-axis label: Date or Time
plt.ylabel('High')  # Y-axis label: Sales data
plt.legend()

plt.subplot(412)
plt.plot(df.index,df['Volume'], label='Trend', color='red')
plt.title('Trend')
plt.xlabel('Date')  # X-axis label: Date or Time
plt.ylabel('Volume')  # Y-axis label: Sales data
plt.legend()

plt.subplot(413)
plt.plot(df.index,df['Adj Close'], label='Seasonal', color='green')
plt.title('Seasonality')
plt.xlabel('Date')  # X-axis label: Date or Time
plt.ylabel('Adj Close')  # Y-axis label: Sales data
plt.legend()

plt.subplot(414)
plt.plot(df.index,df['High'], label='Residual', color='orange')
plt.title('Residuals (Noise)')
plt.xlabel('Date')  # X-axis label: Date or Time
plt.ylabel('High')  # Y-axis label: Sales data
plt.legend()

plt.tight_layout()
plt.show()